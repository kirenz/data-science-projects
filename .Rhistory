library(kknn) # K-nearest neighbor model
# Load the data from GitHub
LINK <- "https://raw.githubusercontent.com/kirenz/datasets/master/oecd_gdp.csv"
df <- read_csv(LINK)
# Take a look at the data
glimpse(df)
# Change column names
df <-  clean_names(df)
# Visualize the data
ggplot(df, aes(x=gdp_per_capita,
y=life_satisfaction)) +
geom_point() +
theme_classic()
# Load common packages
library(tidyverse) # collection of important data science packages
library(tidymodels)  # collection of packages for modeling and ml
library(janitor) # data preparation package
library(kknn) # K-nearest neighbor model
# Change column names
df <-  clean_names(df)
# Visualize the data
ggplot(df, aes(x=gdp_per_capita,
y=life_satisfaction)) +
geom_point() +
theme_classic()
lm_mod <-
linear_reg() %>%
set_engine("lm") %>%
set_mode(mode = "regression")
lm_fit <-
lm_mod %>%
fit(life_satisfaction ~ gdp_per_capita,
data = df)
# Model summary
tidy(lm_fit)
# Predictions
lm_pred <-
lm_fit %>%
predict(new_data = df) %>%
mutate(y_truth = df$life_satisfaction)
head(lm_pred)
glance(lm_fit$fit)
X_new <-  tibble(gdp_per_capita = c(50000)) # new GDP per capita
(predict(lm_fit, new_data = X_new))
knn_mod <-
nearest_neighbor(neighbors = 3) %>%
set_engine("kknn") %>%
set_mode("regression")
knn_fit <-
knn_mod %>%
fit(life_satisfaction ~ gdp_per_capita,
data = df)
(predict(knn_fit, new_data = X_new))
# Model prediction
knn_pred <-
knn_fit %>%
predict(new_data = df) %>%
mutate(y_truth = df$life_satisfaction)
rmse(truth = y_truth, # true values
estimate = .pred,  # model predictions
knn_pred) # data
(predict(knn_fit, new_data = X_new))
# Load the data from GitHub
LINK = "https://raw.githubusercontent.com/kirenz/datasets/master/oecd_gdp.csv"
df <- read_csv(LINK)
# Take a look at the data
glimpse(df)
# Change column names
df <-  clean_names(df)
# Visualize the data
ggplot(df, aes(x=gdp_per_capita,
y=life_satisfaction)) +
geom_point() +
theme_classic()
lm_mod <-
linear_reg() %>%
set_engine("lm") %>%
set_mode(mode = "regression")
knn_mod <-
nearest_neighbor(neighbors = 3) %>%
set_engine("kknn") %>%
set_mode("regression")
set.seed(123)
df_split <- initial_split(df)
df_train <- training(df_split)
df_test <- testing(df_split)
set.seed(123)
cv_folds <- vfold_cv(df_train, v = 5)
# Model summary
lm_fit %>%
collect_metrics(summarize = FALSE)
lm_fit %>%
collect_metrics(summarize = TRUE)
# Load the data from GitHub
LINK = "https://raw.githubusercontent.com/kirenz/datasets/master/oecd_gdp.csv"
df <- read_csv(LINK)
# Take a look at the data
glimpse(df)
# Change column names
df <-  clean_names(df)
# Visualize the data
ggplot(df, aes(x=gdp_per_capita,
y=life_satisfaction)) +
geom_point() +
theme_classic()
lm_mod <-
linear_reg() %>%
set_engine("lm") %>%
set_mode(mode = "regression")
knn_mod <-
nearest_neighbor(neighbors = 3) %>%
set_engine("kknn") %>%
set_mode("regression")
set.seed(123)
df_split <- initial_split(df)
df_train <- training(df_split)
df_test <- testing(df_split)
set.seed(123)
cv_folds <- vfold_cv(df_train, v = 5)
lm_fit <-
lm_mod %>%
fit_resamples(life_satisfaction ~ gdp_per_capita,
resamples = cv_folds)
# Model summary for every split
lm_fit %>%
collect_metrics(summarize = FALSE)
lm_fit %>%
collect_metrics(summarize = TRUE)
# Performance measures for every fold
collect_metrics(lm_fit, summarize = FALSE)
# Average performance accross all folds
collect_metrics(lm_fit, summarize = TRUE)
knn_fit <-
knn_mod %>%
fit_resamples(life_satisfaction ~ gdp_per_capita,
resamples = cv_folds)
last_lm_pred <-
last_lm_fit %>%
predict(new_data = df_test) %>%
mutate(y_truth = df_test$life_satisfaction)
last_lm_fit <-
lm_mod %>%
fit(life_satisfaction ~ gdp_per_capita,
data = df_train)
tidy(last_lm_fit)
last_lm_pred <-
last_lm_fit %>%
predict(new_data = df_test) %>%
mutate(y_truth = df_test$life_satisfaction)
# Performance measures
rmse(truth = y_truth,
estimate = .pred,
last_lm_pred)
glance(last_lm_fit$fit) # more measures
X_new <-  tibble(gdp_per_capita = c(50000))
(predict(last_lm_fit, new_data = X_new))
lm_predicted <-
augment(lm_fit$fit, data = df) %>%
rowid_to_column()
lm_predicted
lm_predicted <-
augment(lm_fit$fit, data = df)
# Load packages
library(tidyverse) # collection of important data science packages
library(tidymodels)  # collection of packages for modeling and ml
library(janitor) # data preparation package
library(kknn) # K-nearest neighbor model
lm_mod <-
linear_reg() %>%
set_engine("lm") %>%
set_mode(mode = "regression")
lm_fit <-
lm_mod %>%
fit(life_satisfaction ~ gdp_per_capita,
data = df)
tidy(lm_fit)
lm_pred <-
lm_fit %>%
predict(new_data = df) %>%
mutate(y_truth = df$life_satisfaction)
head(lm_pred)
lm_predicted <-
augment(lm_fit$fit, data = df) %>%
rowid_to_column()
lm_predicted
lm_predicted <- augment(lm_fit$fit, data = df)
lm_predicted
lm_pred_aug <- augment(lm_fit$fit, data = df)
head(lm_pred_aug)
head(lm_pred)
library(readr)
Facebook_metrics <- read_csv("~/Downloads/Facebook_metrics.csv")
View(Facebook_metrics)
library(tidyverse)
df <- drop_na(Facebook_metrics)
sum(is.na(df))
sum(is.na(Facebook_metrics))
df
View(df)
library(janitor)
Facebook_metrics <- clean_names(Facebook_metrics)
Facebook_metrics
glimpse(Facebook_metrics)
sum(is.na(Facebook_metrics))
df <- drop_na(Facebook_metrics, beitragsinteraktionen )
df
sum(is.na(df))
df
View(df)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
# Load packages
library(tidyverse) # collection of important data science packages
library(tidymodels)  # collection of packages for modeling and ml
library(janitor) # data preparation package
library(kknn) # K-nearest neighbor model
# Load the data from GitHub
LINK = "https://raw.githubusercontent.com/kirenz/datasets/master/oecd_gdp.csv"
df <- read_csv(LINK)
# Take a look at the data
glimpse(df)
# Change column names
df <-  clean_names(df)
# Visualize the data
ggplot(df, aes(x=gdp_per_capita,
y=life_satisfaction)) +
geom_point() +
theme_classic()
lm_mod <-
linear_reg() %>%
set_engine("lm") %>%
set_mode(mode = "regression")
set.seed(123)
df_split <- initial_split(df)
df_train <- training(df_split)
df_test <- testing(df_split)
set.seed(123)
cv_folds <- vfold_cv(df_train, v = 5)
lm_rec <- recipe(formula = life_satisfaction  ~ gdp_per_capita,
data = df) %>%
step_poly(gdp_per_capita, options = list(degree = 6))
lm_rec <- recipe(formula = life_satisfaction  ~ gdp_per_capita,
data = df) %>%
step_poly(gdp_per_capita, degree = 6)
lm_rec
# Prepare recipe
lm_rec_2 <- prep(lm_rec)
View(lm_rec_2)
View(lm_rec)
View(lm_rec_2)
# Show output
head(lm_rec$template)
# Create recipe
lm_rec <-
recipe(formula = life_satisfaction  ~ gdp_per_capita,
data = df) %>%
step_poly(gdp_per_capita, degree = 6)
# Show recipe
lm_rec
# Prepare recipe
lm_rec <- prep(lm_rec)
# Show output
head(lm_rec$template)
# Create a recipe
lm_2_rec <-
recipe(formula = life_satisfaction  ~ gdp_per_capita,
data = df) %>%
step_poly(gdp_per_capita, degree = 6)
# Show recipe
lm_2_rec
# Prepare recipe
lm_2_rec <- prep(lm_2_rec)
# Show recipe output
head(lm_2_rec$template)
lm_fit_2 <-
lm_mod %>%
fit_resamples(life_satisfaction ~ .,
resamples = lm_2_rec$template)
lm_fit_2 <-
lm_mod %>%
fit(life_satisfaction ~ .,
data = lm_2_rec$template)
lm_fit_2
# tuning recipe parameters:
spline_rec <-
recipe(life_satisfaction ~ gdp_per_capita,
data = df) %>%
step_ns(gdp_per_capita, deg_free = tune("gdp_per_capita"))
# manually create a grid
spline_grid <- expand.grid(gdp_per_capita = 2:5)
spline_grid
spline_res <-
tune_grid(lin_mod,
spline_rec,
resamples = cv_folds,
grid = spline_grid)
spline_res <-
tune_grid(lm_mod,
spline_rec,
resamples = cv_folds,
grid = spline_grid)
spline_res
show_best(spline_res, metric = "rmse")
show_best
show_best(spline_res, metric = "rmse")
parameters(spline_rec)
# Detect and collect the parameters that have been flagged for tuning
parameters(spline_rec)
spline_param <-
spline_rec %>%
parameters() %>%
update(
gdp_per_capita = spline_degree()
)
spline_param
spline_degree()
spline_degree()
spline_param
# Manually create a grid
spline_grid <- grid_max_entropy(spline_param, size = 10)
spline_grid
lm_mod_sp <-
linear_reg() %>%
set_engine("lm")
spline_res
show_best(spline_res, metric = "rmse")
spline_res <-
tune_grid(lm_mod_sp,
spline_rec,
resamples = cv_folds,
grid = spline_grid)
spline_res
show_best(spline_res, metric = "rmse")
# Create a grid
spline_grid <- grid_max_entropy(spline_param, size = 5)
lm_mod_sp <-
linear_reg() %>%
set_engine("lm")
spline_res <-
tune_grid(lm_mod_sp,
spline_rec,
resamples = cv_folds,
grid = spline_grid)
spline_res
show_best(spline_res, metric = "rmse")
estimates <- collect_metrics(spline_res)
estimates
spline_res$.metrics[[1]]
spline_res$.metrics[[1]]
rmse_vals <-
estimates %>%
dplyr::filter(.metric == "rmse") %>%
arrange(mean)
rmse_vals
autoplot(ames_res, metric = "rmse")
autoplot(splines_res, metric = "rmse")
autoplot(spline_res, metric = "rmse")
# Change column names
df <-  clean_names(df)
# Visualize the data
ggplot(df, aes(x=gdp_per_capita,
y=life_satisfaction)) +
geom_point() +
theme_classic()
parameters(spline_rec)
ctrl <- control_bayes(verbose = TRUE)
set.seed(8154)
knn_search <- tune_bayes(knn_wflow,
resamples = cv_splits,
initial = 5,
iter = 20,
param_info = knn_param,
control = ctrl)
knn_param <-
knn_wflow %>%
parameters() %>%
update(
gdp_per_capita = spline_degree(c(2, 5)),
neighbors = neighbors(c(3, 10)),
weight_func = weight_func(values = c("rectangular",
"inv",
"gaussian",
"triangular"))
)
library(workflows)
knn_wflow <-
workflow() %>%
add_model(knn_mod) %>%
add_recipe(df_rec)
knn_mod <-
nearest_neighbor(neighbors = tune(),
weight_func = tune()) %>%
set_engine("kknn") %>%
set_mode("regression")
library(workflows)
knn_wflow <-
workflow() %>%
add_model(knn_mod) %>%
add_recipe(df_rec)
df_rec <-
recipe(life_satisfaction ~ gdp_per_capita,
data = df_train) %>%
step_ns(gdp_per_capita,
deg_free = tune("gdp_per_capita")) # tuning parmeter for model 2
knn_mod <-
nearest_neighbor(neighbors = tune(),
weight_func = tune()) %>%
set_engine("kknn") %>%
set_mode("regression")
library(workflows)
knn_wflow <-
workflow() %>%
add_model(knn_mod) %>%
add_recipe(df_rec)
knn_param <-
knn_wflow %>%
parameters() %>%
update(
gdp_per_capita = spline_degree(c(2, 5)),
neighbors = neighbors(c(3, 10)),
weight_func = weight_func(values = c("rectangular",
"inv",
"gaussian",
"triangular"))
)
ctrl <- control_bayes(verbose = TRUE)
set.seed(8154)
knn_search <- tune_bayes(knn_wflow,
resamples = cv_splits,
initial = 5,
iter = 20,
param_info = knn_param,
control = ctrl)
ctrl <- control_bayes(verbose = TRUE)
set.seed(8154)
knn_search <- tune_bayes(knn_wflow,
resamples = cv_folds,
initial = 5,
iter = 20,
param_info = knn_param,
control = ctrl)
autoplot(knn_search, type = "performance", metric = "rmse")
collect_metrics(knn_search) %>%
dplyr::filter(.metric == "rmse") %>%
arrange(mean)
library(workflow)
lm_mod_workflow <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
lm_mod_workflow
library(workflows)
lm_mod_wf <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
lm_mod_wf
lm_fit <-
lm_mod_wf %>%
fit_resamples(resamples = cv_folds)
library(workflows)
lm_mod_wf <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
lm_mod_wf
lm_fit <-
lm_mod_wf %>%
fit_resamples(resamples = cv_folds)
library(workflows)
lm_mod_wf <-
workflow() %>%
add_model(lm_mod) #%>%
#add_recipe(df_rec)
lm_mod_wf
lm_fit <-
lm_mod_wf %>%
fit_resamples(resamples = cv_folds)
lm_mod <-
linear_reg() %>%
set_engine("lm") %>%
set_mode(mode = "regression")
library(workflows)
lm_mod_wf <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
lm_mod_wf
lm_fit <-
lm_mod_wf %>%
fit_resamples(resamples = cv_folds)
lm_fit <-
lm_mod %>%
fit_resamples(life_satisfaction ~ gdp_per_capita,
data = df_train
resamples = cv_folds)
lm_fit <-
lm_mod %>%
fit_resamples(life_satisfaction ~ gdp_per_capita,
data = df_train) %>%
resamples = cv_folds)
lm_fit <-
lm_mod %>%
fit_resamples(life_satisfaction ~ gdp_per_capita,
resamples = cv_folds)
# Performance measures for every fold
collect_metrics(lm_fit, summarize = FALSE)
# Average performance accross all folds
collect_metrics(lm_fit, summarize = TRUE)
